from networkx import MultiDiGraph
from LPR.data.rules import Rules
from LPR.algorithms.bfs import bfs


def h1(relation: str, graph: MultiDiGraph, e: set[tuple[str, str]]):
    """
    :param e: edges labeled by relation r
    :param relation: relation asiciated with generated rules
    :param graph: input facts as MultiDiGraph
    :return: rules generated by Heuristic 1 (all length 1 and 2)
    """

    edges = e
    rules = Rules(relation, edges)
    edges_agg = dict()
    for edge in edges:
        if edge[0] in edges_agg.keys():
            edges_agg[edge[0]].append(edge[1])
        else:
            edges_agg[edge[0]] = [edge[1]]

    for x in edges_agg:
        y = edges_agg[x]
        # find edges from X to Y not labeled by r
        for first_edge in [e for e in graph.edges(x, data='relation')]:
            if (first_edge[1] in y) & (first_edge[2] != relation):
                # length 1 rule
                # found edge, increment count or create new Rule
                rules.add_rule(relation, new_clause=[first_edge[2]], tail_head=[first_edge[0], first_edge[1]], increment=True, )

            elif (first_edge[1] not in y) & (first_edge[2] != relation):
                # check if selected edge can be used in length 2 rule
                for second_edge in graph.edges(first_edge[1], data='relation'):
                    # add second edge if it leads to one of valid end points and that end point is not current x
                    if (second_edge[1] in y) & (second_edge[1] != x):
                        # found edge, increment count or create new length 2 Rule
                        rules.add_rule(relation, new_clause=[first_edge[2], second_edge[2]], tail_head=[first_edge[0], second_edge[1]], increment=True)

    # generate length 1 and 2 rules, that create min 1 path from X to Y
    # find paths from X to Y for each edge labeled by r (paths cant use edges labeled by r)
    # for edge in edges:
    #     x = edge[0]
    #     y = edge[1]
    #     # find edges from X to Y not labeled by r
    #     for first_edge in [e for e in graph.edges(x, data='relation')]:
    #         if (first_edge[1] == y) & (first_edge[2] != relation):
    #             # length 1 rule
    #             # found edge, increment count or create new Rule
    #             rules.add_rule(relation, new_clause=[first_edge[2]], increment=True)
    #
    #         elif (first_edge[1] != y) & (first_edge[2] != relation):
    #             # check if selected edge can be used in length 2 rule
    #             for second_edge in graph.edges(first_edge[1], data='relation'):
    #                 if second_edge[1] == y:
    #                     # found edge, increment count or create new length 2 Rule
    #                     rules.add_rule(relation, new_clause=[first_edge[2], second_edge[2]], increment=True)

    return rules


def h2(relation: str, graph: MultiDiGraph, e: set[tuple[str, str]], max_complexity: int):
    """
    :param e: set of edges labeled by r
    :param relation: relation asiciated with generated rules
    :param graph: input facts as MultiDiGraph
    :return: rules generated by Heuristic 2 (shortest paths from X to Y for edges labeled by r)
    :param max_complexity: maximal length of paths used to create rules
    """
    edges = e
    rules = Rules(relation, edges)

    for edge in edges:
        x = edge[0]
        y = edge[1]

        # find shortest path using breadth first algorith
        paths = bfs(x, y, graph, max_length=max_complexity, skipped_r=relation, n=1)

        # create rules from paths
        for path in paths:
            sequence = []
            tail_head = (path[0][0], path[-1][1])
            for edge in path:
                sequence.append(edge[2])
            rules.add_rule(relation, sequence, tail_head=tail_head)

    # find how frequently do rules create paths from X to Y for each edge and update rules
    freq = rules.get_paths(relation, edges, graph, mode='count_valid')
    for id in rules.rules[relation]:
        rules.rules[relation][id]['freq'] = freq[id]

    # print("\t", len(rule_paths), " : ", rule_paths)

    return rules

