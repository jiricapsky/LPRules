from networkx import MultiDiGraph
from LPR.algorithms.heuristics import h1, h2
from pulp import LpMinimize, LpProblem, LpVariable, lpSum
import LPR.lpr as lpr


class Model:
    def __init__(self, relation: str, graph: MultiDiGraph, edges: set[tuple[str, str]]):
        """
        :param relation: relation from graph
        :param graph: graph from which rules are created for relation r
        """
        self.relation = relation
        self.edges = edges
        # setup K0 using heuristic 1 and 2
        rules_h1 = h1(relation, graph, edges)
        rules_h2 = h2(relation, graph, edges, 5)

        # print("----------------------")
        # rs.printAsList(rules_h1)
        # rs.printAsList(rules_h2)
        # print("----------------------")

        # combine rules generated by both heuristics
        self.rules = rules_h1.combine(rules_h1, rules_h2)

        # calculate number of invalid start and end points
        self.rules.calculate_neg(relation, edges, graph)
        # self.rules.printAsList()

    def train(self, validation: MultiDiGraph, iterations: int, all_t : []):
        """
        :param iterations: number of iterations
        :param validation: validation part of dataset
        :param all_t: weight given to negative sampling
        :return:
        """
        # find initial value of complexity (length of longest rule + 1)
        k = 0
        for id in self.rules.rules[self.relation]:
            length = len(self.rules.rules[self.relation][id]['clause'])
            if length > k:
                k = length

        results = []
        # for each t run 20 iterations where at the ith iteration k = ik
        for t in all_t:
            for iteration in range(1, iterations + 1):
                weights = self.solve_LP(t, iteration * k)
                # update weights
                for id in self.rules.rules[self.relation]:
                    self.rules.setWeight(id, weights[id])

                mrr = lpr.predict(validation, [self.rules], options=['only_mrr'])

                combination = {'weights': weights, 'mrr': mrr, 't': t, 'k': iteration * k}
                results.append(combination)

                print("------\n{0}/{1} : for t = {2}/{3}\n{4}\n------\n".format(iteration, iterations, t, all_t, combination))

        results.sort(reverse=True, key= lambda result: result['mrr'])
        for result in results:
            print(result)

    def solve_LP(self, t, complexity):
        # initialize model
        model = LpProblem(name=self.relation, sense=LpMinimize)

        # create list of variables w_k and neg_k for each rule
        K = len(self.rules.rules[self.relation])
        w = dict()
        neg = []
        # w.extend(range(K))
        neg.extend(range(K))
        for k in range(K):
            w[k] = LpVariable(name="w_{0}".format(k), lowBound=0, upBound=1.0)
            neg_k = self.rules.rules[self.relation][k]['neg'][0] + self.rules.rules[self.relation][k]['neg'][1]
            neg[k] = neg_k

        # create variable penalty and constraints for each edge
        penalty = []
        penalty.extend(range(len(self.edges)))
        x = 0
        for e in self.edges:
            penalty[x] = LpVariable(name="n_" + str(x))
            # add constraint for each edge
            c = lpSum([int(self.rules.is_path(k, e)) * w[k] for k in range(K)]) + penalty[x] >= 1
            model += (c, "constraint_{0}:{1}".format(e[0], e[1]))
            x += 1

        # upper bound of complexity
        # complexity = sum([(1 + len(self.rules.rules[self.relation][k]['clause'])) for k in range(K)])
        upper_complex = lpSum([((1 + len(self.rules.rules[self.relation][k]['clause'])) * w[k]) for k in range(K)]) <= complexity
        model += (upper_complex, "upper_complex")

        # expression
        z = sum(penalty) + t * lpSum([neg[k] * w[k] for k in range(K)])
        model += (z, "obj_function")

        # print(model)
        model.solve()

        result = dict()
        # update rule weights
        for id in w:
            result[id] = w[id].value()
            # self.rules.setWeight(id, w[id].value())

        return result
