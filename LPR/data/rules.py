import pandas as pd

from networkx import MultiDiGraph

_clause = 'clause'
_relation = 'relation'
_frequency = 'freq'
_neg = 'neg'
_weight = 'weight'
_paths = 'paths'

_query_modes = ['all', 'valid', 'count_valid']


class Rules:

    def __init__(self, relation: str, edges: []):
        self.relation = relation
        self.rules = dict({relation: {}})
        self.nodes = set()
        for edge in edges:
            self.nodes.add(edge[0])
            self.nodes.add(edge[1])

    def add_rule(self, relation, new_clause: list[str], tail_head=tuple(["", ""]), frequency=1, neg=None, weight=0, increment=False):
        """
        Appends new rule if it hasn't been added before. Argument increment is used to specify if frequency of existing
        rule should be increased. Duplicates are not added.
        :param weight: weight of rule, default is 0 and value is assigned after solving LP
        :param relation: relation associated with the new rule
        :param new_clause: list of relations
        :param tail_head: tail and head of path
        :param frequency: number of paths created by this rule for all edges labeled by 'relation' in graph
        :param neg: number of "nonedges" of rule if normat [left_k, right_k]
        :param increment: True if frequency of existing rule should be increased when trying to add duplicate rule, default is True
        """
        if neg is None:
            neg = list([0, 0])
        for rule in self.rules[relation]:
            if self.rules[relation][rule][_clause] == new_clause:
                if increment:
                    self.rules[relation][rule][_frequency] += 1
                if (tail_head[0] != "") & (tail_head[1] != ""):
                    self.rules[relation][rule][_paths].loc[tail_head[0], tail_head[1]] = 1
                return

        # prepare dataframe
        # d = pd.DataFrame(columns=self.nodes, index=self.nodes)
        # d.fillna(0, inplace=True)
        d = pd.DataFrame()
        if (tail_head[0] != "") & (tail_head[1] != ""):
            d.loc[tail_head[0], tail_head[1]] = 1
        # print(d)
        self.rules[relation][len(self.rules[relation])] = {_clause: new_clause,
                                                           _frequency: frequency,
                                                           _neg: neg,
                                                           _weight: weight,
                                                           _paths: d}

    def printAsList(self):
        for r in self.rules.keys():
            print(r)
            # sorts rules asociated with relation r by frequency (descending)
            sorted_rules = dict(sorted(self.rules[r].items(), key=lambda x: x[1][_weight], reverse=True))
            for id in sorted_rules:
                print("\t", sorted_rules[id][_weight], " ",
                      sorted_rules[id][_frequency], " ",
                      sorted_rules[id][_neg], " ",
                      " : ", sorted_rules[id][_clause],
                      # "\n\t", sorted_rules[id][_paths]
                      )

    def combine(self, rules1: 'Rules', rules2: 'Rules'):
        result = rules1
        for r in rules2.rules.keys():
            for id in rules2.rules[r]:
                # try adding rule to rules2
                self.add_rule(r, rules2.rules[r][id][_clause], frequency=rules2.rules[r][id][_frequency],
                              increment=False)

        return result

    def calculate_neg(self, relation, edges: [list[str, str]], graph: MultiDiGraph):
        rule_paths_tail = self.get_paths(relation, edges, graph, mode='all')
        rule_paths_head = self.get_paths(relation, edges, graph, mode='all', reversed_query=True)
        # update number of invalid end points
        for id in rule_paths_tail:
            # print(len(rule_paths_tail[id]), " : ", rule_paths_tail[id])
            # all paths generated by method self.get_paths() start from nodes from edges labeled by relation r
            # so right_k for each rule can be calculated as: right_k = |paths| - frequency
            self.rules[relation][id][_neg][1] = len(rule_paths_tail[id]) - self.rules[relation][id][_frequency]

        # update number of invalid start points
        for id in rule_paths_head:
            # print(len(rule_paths_head[id]), " : ", rule_paths_head[id])
            self.rules[relation][id][_neg][0] = len(rule_paths_head[id]) - self.rules[relation][id][_frequency]

    def get_paths(self, relation, edges: set[tuple[str, str]], graph: MultiDiGraph, mode='all', reversed_query=False):
        result = dict()

        # end if selected mode is not valid
        if mode not in _query_modes:
            print("Invalid mode '", mode, "', select mode from: ", _query_modes, ", or keep defaul mode 'all'")
            return result

        for id in self.rules[relation]:
            # find paths for each edge using rule
            # print(self.rules[relation][id])
            rule_paths = []
            for edge in edges:
                if reversed_query:
                    paths = [[edge[1]]]
                else:
                    paths = [[edge[0]]]
                queue = self.rules[relation][id]['clause'].copy()

                new_paths = []
                visited = []
                # find paths using relations from queue
                while queue:
                    for path in paths:
                        node = path.copy()
                        # check if node is single entity or edge
                        if reversed_query & (len(node) > 1):
                            node = node[-1][0]
                        elif (not reversed_query) & (len(node) > 1):
                            node = node[-1][1]
                        else:
                            node = node[0]
                        # iterate over graph edges
                        if reversed_query:
                            # find all edges labeled by relation from queue, where previous node has not been visited
                            for neighbour in [e for e in graph.in_edges(node, data='relation') if
                                              (e[2] == queue[-1]) & (e[0] not in visited)]:
                                new_path = list(path)
                                new_path.append(neighbour)
                                new_paths.append(new_path)

                                # check if this relation is last in queue
                                # and append to rule_paths if condition satisfied and path is not already in rule_paths
                                # mode: valid = add only if path ends in node in edge[1]
                                if (len(queue) == 1) & (new_path[1:] not in rule_paths):
                                    if (neighbour[1] == edge[1]) & (mode == 'valid'):
                                        rule_paths.append(new_path[1:])
                                        # print("\t", new_path[1:])
                                    elif mode == 'all':
                                        rule_paths.append(new_path[1:])
                        else:
                            # find all edges labeled by relation from queue, where following node has not been visited
                            for neighbour in [e for e in graph.edges(node, data='relation') if
                                              (e[2] == queue[0]) & (e[1] not in visited)]:

                                new_path = list(path)
                                new_path.append(neighbour)
                                new_paths.append(new_path)

                                # check if this relation is last in queue
                                # and append to rule_paths if condition satisfied and path is not already in rule_paths
                                # mode: valid = add only if path ends in node in edge[1]
                                if (len(queue) == 1) & (new_path[1:] not in rule_paths):
                                    if (neighbour[1] == edge[1]) & (mode == 'valid'):
                                        rule_paths.append(new_path[1:])
                                        # print("\t", new_path[1:])
                                    elif mode == 'all':
                                        rule_paths.append(new_path[1:])

                        # append node to visited when all neighbours are discovered
                        visited.append(node)

                    paths = new_paths.copy()
                    new_paths.clear()

                    if reversed_query:
                        queue.pop(-1)
                    else:
                        queue.pop(0)

            # append to result
            # just number of paths created by rule if selected mode is 'count'
            if mode == 'count_valid':
                result[id] = len(rule_paths)
            elif (mode == 'valid') | (mode == 'all'):
                result[id] = rule_paths

        return result

    def is_path(self, rule_id, tail_head: []):
        try:
            result = self.rules[self.relation][rule_id][_paths].loc[tail_head[0], tail_head[1]]
            if result == 1:
                return result
        except KeyError:
            return 0

    def setWeight(self, rule_id, newWeight):
        if rule_id in self.rules[self.relation].keys():
            self.rules[self.relation][rule_id][_weight] = newWeight

    def is_unknown_path(self, rule_id, tail_head: [str, str], graph: MultiDiGraph, reversed=False):
        queue = self.rules[self.relation][rule_id][_clause].copy()
        paths = [[tail_head[0]]]
        if reversed:
            queue.reverse()
            paths = [[tail_head[1]]]
        visited = []

        while queue:
            new_paths = []
            for path in paths:
                node = path.copy()
                # check if node is single entity or edge
                if (len(node) > 1) & (not reversed):
                    node = node[-1][1]
                elif (len(node) > 1) & reversed:
                    node = node[-1][0]
                else:
                    node = node[0]

                if reversed:
                    neighbours = []
                    for t, h, r in graph.edges(data='relation'):
                        if (t not in visited) & (r == queue[0]) & (h == node):
                            neighbours.append((t, h, r))
                else:
                    neighbours = [e for e in graph.edges(node, data='relation') if
                                  (e[2] == queue[0]) & (e[1] not in visited)]

                for neighbour in neighbours:
                    new_path = list(path)
                    new_path.append(neighbour)
                    new_paths.append(new_path)

                    if reversed:
                        if (len(queue) == 1) & (neighbour[0] == tail_head[0]) & (neighbour[0] not in visited):
                            return True
                    else:
                        if (len(queue) == 1) & (neighbour[1] == tail_head[1]) & (neighbour[1] not in visited):
                            return True

                visited.append(node)

            paths = new_paths.copy()
            new_paths.clear()

            queue.pop(0)

        return False
